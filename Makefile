# Install Cursor rules to the user or system rules directory.
# Override with: make install RULES_DIR=/path/to/.cursor/rules
# Or for staged installs: make install DESTDIR=/staging HOME=/staging/home/user
OS_TYPE := $(shell uname -s)

RULES_DIR ?= $(HOME)/.cursor/rules
SKILLS_DIR ?= $(HOME)/.claude/skills
CODEX_SKILLS_DIR ?= $(HOME)/.codex/skills
DESTDIR ?=

# Generated by make skills (from skills/source/delve.tmpl); install copies from skills/out
RULES_SRC := skills/out/cursor
RULES_DEST := $(DESTDIR)$(RULES_DIR)
SKILLS_SRC := skills/out/claude
SKILLS_DEST := $(DESTDIR)$(SKILLS_DIR)
CODEX_SKILLS_SRC := skills/out/codex
CODEX_SKILLS_DEST := $(DESTDIR)$(CODEX_SKILLS_DIR)
TEMPLATE_DIR  ?= $(HOME)/.local/share/delve-debug
TEMPLATE_DEST := $(DESTDIR)$(TEMPLATE_DIR)

.PHONY: install install-deps install-pandoc install-pdflatex install-pygments install-delve install-delve-helper install-rules install-skill install-codex-skill install-template uninstall uninstall-delve uninstall-delve-helper uninstall-rules uninstall-skill uninstall-codex-skill uninstall-template delve-helper generate-skills skills check-templates install-hooks lint debug-example debug-example-crash clean-debug reset-examples reset-example-crash run-example run-example-crash test-example test-e2e

# 1) skills → generate into skills/out/  2) install-* → copy skills/out/... to ~/.cursor/rules, ~/.claude/skills, ~/.codex/skills
install: skills install-deps install-delve install-delve-helper install-rules install-skill install-codex-skill install-template
	@echo "delve-helper on PATH: $$(command -v delve-helper 2>/dev/null || echo 'not yet — open a new shell or add ~/.local/bin to PATH')"

install-deps: install-pandoc install-pdflatex install-pygments

# Install pandoc (Markdown → LaTeX converter for report generation).
install-pandoc:
	@if command -v pandoc >/dev/null 2>&1; then \
		echo "pandoc already installed: $$(pandoc --version | head -1)"; \
	elif [ "$(OS_TYPE)" = "Darwin" ]; then \
		echo "Installing pandoc via Homebrew..."; \
		brew install pandoc; \
	elif command -v apt-get >/dev/null 2>&1; then \
		echo "Installing pandoc via apt-get..."; \
		sudo apt-get install -y pandoc; \
	else \
		echo "ERROR: pandoc not found and no supported package manager detected." >&2; \
		echo "       Install manually: https://pandoc.org/installing.html" >&2; \
		exit 1; \
	fi

# Install pdflatex + minted package (PDF compilation).
# On macOS: installs BasicTeX (minimal) then adds minted and required packages via tlmgr.
# On Linux:  installs texlive-latex-extra which includes minted.
install-pdflatex:
	@if command -v pdflatex >/dev/null 2>&1; then \
		echo "pdflatex already installed: $$(pdflatex --version | head -1)"; \
	elif [ "$(OS_TYPE)" = "Darwin" ]; then \
		echo "Installing BasicTeX via Homebrew (this may take a while)..."; \
		brew install --cask basictex; \
		echo "Updating tlmgr and installing minted + required LaTeX packages..."; \
		sudo tlmgr update --self; \
		sudo tlmgr install minted fvextra upquote catchfile xstring framed collection-fontsrecommended; \
	elif command -v apt-get >/dev/null 2>&1; then \
		echo "Installing texlive-latex-extra via apt-get (this may take a while)..."; \
		sudo apt-get install -y texlive-latex-extra texlive-fonts-recommended; \
	else \
		echo "ERROR: pdflatex not found and no supported package manager detected." >&2; \
		echo "       Install TeX Live or MacTeX: https://tug.org/texlive/" >&2; \
		exit 1; \
	fi

# Install Pygments (Python package required by minted for syntax highlighting).
install-pygments:
	@if command -v pygmentize >/dev/null 2>&1; then \
		echo "pygments already installed: $$(pygmentize --version 2>/dev/null || echo ok)"; \
	elif command -v pip3 >/dev/null 2>&1; then \
		echo "Installing pygments via pip3..."; \
		pip3 install pygments; \
	elif command -v pip >/dev/null 2>&1; then \
		echo "Installing pygments via pip..."; \
		pip install pygments; \
	else \
		echo "ERROR: pip/pip3 not found. Install Python 3 then run: pip3 install pygments" >&2; \
		exit 1; \
	fi

# Build the delve-helper CLI (used by debug-example and for dynamic debugging).
delve-helper:
	@go build -o delve-helper ./cmd/delve-helper

# Regenerate agent skill files from the canonical template (skills/source/delve.tmpl).
generate-skills:
	@go run ./cmd/skillgen

# Generate all skills into a folder for manual review (default: skills/out). Override with make skills OUT=<dir>.
SKILLS_OUT ?= skills/out
skills:
	@go run ./cmd/skillgen -out "$(SKILLS_OUT)" && echo "Review generated skills in $(SKILLS_OUT)/"

# Fail if examples/templates/ has uncommitted changes (pristine snapshots for reset-examples).
check-templates:
	@./scripts/check-templates-unchanged.sh

# Run Go linter (used by pre-commit hook and CI).
lint:
	@go vet ./...

# Install git hooks: pre-commit runs template check + lint (blocks commit on failure).
install-hooks:
	@mkdir -p .git/hooks
	@cp .githooks/pre-commit .git/hooks/pre-commit
	@chmod +x .git/hooks/pre-commit
	@echo "Installed .git/hooks/pre-commit (template check + go vet ./...)"

# Start headless Delve for ./examples/failing_test (--accept-multiclient, address in .dlv/addr). Use with delve-helper break/continue/print etc.
debug-example: delve-helper
	@./delve-helper start ./examples/failing_test

# Remove Delve debug binaries (__debug_bin*) left in the tree when using dlv directly (without delve-helper).
clean-debug:
	@find . -maxdepth 3 -name '__debug_bin*' -type f -print -delete

GOPATH_BIN := $(shell go env GOPATH)/bin
DLV := $(GOPATH_BIN)/dlv

install-delve:
	@echo "Installing delve (dlv) globally..."
	@go install github.com/go-delve/delve/cmd/dlv@latest || \
		(echo "dlv install via GOPROXY failed; retrying with GOPROXY=direct" && \
		GOPROXY=direct go install github.com/go-delve/delve/cmd/dlv@latest)
	@mkdir -p "$(HOME)/.local/bin"
	@ln -sf "$(DLV)" "$(HOME)/.local/bin/dlv"
	@echo "linked $(HOME)/.local/bin/dlv -> $(DLV)"
	@echo "delve installed: $$($(DLV) version 2>/dev/null || true)"
	@echo "dlv on PATH: $$(command -v dlv 2>/dev/null || echo 'not yet — open a new shell')"

install-delve-helper:
	@echo "Installing delve-helper globally..."
	@$(MAKE) delve-helper
	@mkdir -p "$(HOME)/.local/bin"
	@install -m 755 delve-helper "$(HOME)/.local/bin/delve-helper"
	@echo "installed delve-helper -> $(HOME)/.local/bin/delve-helper"

# Copy generated skills from skills/out/ to agent directories
install-rules:
	@mkdir -p "$(RULES_DEST)"
	@for f in $(RULES_SRC)/*.mdc; do \
		[ -f "$$f" ] || continue; \
		install -m 644 "$$f" "$(RULES_DEST)/"; \
		echo "installed $$f -> $(RULES_DEST)/$$(basename $$f)"; \
	done

install-skill:  # skills/out/claude/<name>/SKILL.md -> $(SKILLS_DEST)/<name>/SKILL.md
	@for d in $(SKILLS_SRC)/*/; do \
		[ -d "$$d" ] || continue; \
		name=$$(basename "$$d"); \
		mkdir -p "$(SKILLS_DEST)/$$name"; \
		install -m 644 "$$d/SKILL.md" "$(SKILLS_DEST)/$$name/SKILL.md"; \
		echo "installed $$d/SKILL.md -> $(SKILLS_DEST)/$$name/SKILL.md"; \
	done

install-codex-skill:  # skills/out/codex/*/ -> $(CODEX_SKILLS_DEST)
	@for d in $(CODEX_SKILLS_SRC)/*/; do \
		[ -d "$$d" ] || continue; \
		name=$$(basename "$$d"); \
		mkdir -p "$(CODEX_SKILLS_DEST)/$$name"; \
		cp -r "$$d"* "$(CODEX_SKILLS_DEST)/$$name/"; \
		echo "installed $$d -> $(CODEX_SKILLS_DEST)/$$name/"; \
	done

install-template: delve-helper
	@./delve-helper install-templates

uninstall: uninstall-delve uninstall-delve-helper uninstall-rules uninstall-skill uninstall-codex-skill uninstall-template

uninstall-delve:
	@rm -f "$(HOME)/.local/bin/dlv" 2>/dev/null && echo "removed $(HOME)/.local/bin/dlv" || true
	@rm -f "$(GOPATH_BIN)/dlv" 2>/dev/null && echo "removed $(GOPATH_BIN)/dlv" || true

uninstall-delve-helper:
	@rm -f "$(HOME)/.local/bin/delve-helper" 2>/dev/null && echo "removed $(HOME)/.local/bin/delve-helper" || true

uninstall-rules:
	@for f in $(RULES_SRC)/*.mdc; do \
		[ -f "$$f" ] || continue; \
		b="$$(basename "$$f")"; \
		rm -f "$(RULES_DEST)/$$b" 2>/dev/null; \
		echo "removed $(RULES_DEST)/$$b"; \
	done

uninstall-skill:
	@for d in $(SKILLS_SRC)/*/; do \
		[ -d "$$d" ] || continue; \
		name=$$(basename "$$d"); \
		rm -rf "$(SKILLS_DEST)/$$name" 2>/dev/null; \
		echo "removed $(SKILLS_DEST)/$$name"; \
	done

uninstall-codex-skill:
	@for d in $(CODEX_SKILLS_SRC)/*/; do \
		[ -d "$$d" ] || continue; \
		name=$$(basename "$$d"); \
		rm -rf "$(CODEX_SKILLS_DEST)/$$name" 2>/dev/null; \
		echo "removed $(CODEX_SKILLS_DEST)/$$name"; \
	done

uninstall-template:
	@rm -rf "$(TEMPLATE_DEST)" 2>/dev/null && echo "removed $(TEMPLATE_DEST)" || true

## reset-examples: Restore both examples/failing_test and examples/crash from examples/templates.
## 1) Delete all contents of the target dirs (never touch examples/templates). 2) Copy from templates for a perfect clean state.
reset-examples:
	@test -d examples/templates/failing_test && test -d examples/templates/crash || (echo "ERROR: examples/templates/failing_test and examples/templates/crash must exist" >&2; exit 1)
	@echo "→ Resetting examples/failing_test/ (delete contents, then copy from templates)..."
	@rm -rf examples/failing_test
	@mkdir -p examples/failing_test
	@cp examples/templates/failing_test/* examples/failing_test/
	@echo "→ Resetting examples/crash/ (delete contents, then copy from templates)..."
	@rm -rf examples/crash
	@mkdir -p examples/crash
	@cp examples/templates/crash/* examples/crash/
	@echo "→ Done. 'make run-example' / 'make test-example' or 'make run-example-crash'. 'make debug-example' / 'make debug-example-crash' for Delve."

## run-example: Run the buggy pipeline (exit 1 expected).
run-example:
	@echo "→ Running sensor pipeline (failure expected)..."
	@cd examples/failing_test && go run . || true

## test-example: Run tests against the buggy pipeline (failures expected).
test-example:
	@echo "→ Testing sensor pipeline (failures expected)..."
	@cd examples/failing_test && go test -v ./... || true

## reset-example-crash: Restore only examples/crash/ (delete contents, then copy from examples/templates/crash).
reset-example-crash:
	@test -d examples/templates/crash || (echo "ERROR: examples/templates/crash must exist" >&2; exit 1)
	@echo "→ Resetting examples/crash/ (delete contents, then copy from templates)..."
	@rm -rf examples/crash
	@mkdir -p examples/crash
	@cp examples/templates/crash/* examples/crash/
	@echo "→ Done. 'make run-example-crash' to see the panic."
	@echo "   'make debug-example-crash' to start a Delve session."

## run-example-crash: Run the crashing pipeline (panic expected).
run-example-crash:
	@echo "→ Running signal processor (panic expected)..."
	@cd examples/crash && go run . || true

## debug-example-crash: Start headless Delve for ./examples/crash.
debug-example-crash: delve-helper
	@./delve-helper start ./examples/crash

## test-e2e: Full end-to-end test: reset → Delve session → fix → PDF → assertions.
## Rebuilds and installs delve-helper first so the PATH binary is always current.
test-e2e: install-delve-helper
	@echo "→ Running end-to-end integration test..."
	@go test -v -tags integration -timeout 120s ./e2e/
